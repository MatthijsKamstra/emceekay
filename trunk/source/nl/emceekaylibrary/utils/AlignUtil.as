// @author Eric-Paul Lecluse | epologee.com (c) 2009// @author David Knape// @author Matthijs Kamstra aka [mck]package nl.emceekaylibrary.utils{        import flash.display.DisplayObject;	import flash.events.Event;   	import flash.geom.Rectangle;   	    /**	* Alignment utilities	* use to align objects to the stage	* 	* works with rectangle, no x and y yet	* 	* @example		new AlignUtil (foobarMC);										// align default top right	* 				new AlignUtil (foobarMC, AlignUtil.BOTTOM_RIGHT);				// align bottom right	* 				new AlignUtil (background, AlignUtil.CENTER_TOP, null, true); 	// align centertop and follow resize 	* 				new AlignUtil (mainContainer, AlignUtil.CENTER_TOP, new Rectangle(0, 0, 500, 400), true); 	// 	* 	*/		public class AlignUtil	{		public static const TOP_LEFT		: String = "TL";		public static const TOP_RIGHT		: String = "TR";		public static const BOTTOM_RIGHT 	: String = "BR";		public static const BOTTOM_LEFT 	: String = "BL";		public static const CENTER 			: String = "C";		public static const CENTER_TOP 		: String = "CT";		public static const CENTER_BOTTOM	: String = "CB";		//		private var _alignment : String;		private var _displayObject:DisplayObject;		private var _rectangle:Rectangle;				/**		 * constructor AlignUtil		 * used to align a displayObject (MovieClip, Sprite, etc) to the borders of the stage		 * 		 * @example			new AlignUtil (foobarMC, AlignUtil.BOTTOM_RIGHT);		 * 		 * @param	inDisplayObject		object that needs to be aligned		 * @param	inAlignment			where does the object need to go (default: TOP_RIGHT)		 * @param	inRec				use to define size of inDisplayObject, otherwise it will use width/height of inDisplayObject		 * @param	inIsFollow			react to resize stage (default: false)		 */		public function AlignUtil(inDisplayObject:DisplayObject, inAlignment:String = TOP_RIGHT, inRec:Rectangle = null,	inIsFollow:Boolean = false) 		{			//trace( "AlignUtil.AlignUtil > inDisplayObject : " + inDisplayObject + ", inAlignment : " + inAlignment + ", inRec : " + inRec + ", inIsFollow : " + inIsFollow );			_alignment = inAlignment;			_displayObject = inDisplayObject;			if (inRec == null) inRec = new Rectangle();			if (inRec.width == 0) inRec.width = inDisplayObject.width;			if (inRec.height == 0) inRec.height = inDisplayObject.height;			_rectangle = inRec;			if (inIsFollow) {				_displayObject.addEventListener(Event.ADDED_TO_STAGE, startAlignmentHandler);				if (_displayObject.stage) {					startAlignmentHandler(null);				}			} else {				align(null);			}		}				/**		 * see constructor 		 * @param	inDisplayObject		object that needs to be aligned		 * @param	inAlignment			where does the object need to go (default: TOP_RIGHT)		 * @param	inRec				use to define size of inDisplayObject, otherwise it will use width/height of inDisplayObject		 * @param	inIsFollow			react to resize stage (default: false)		 */		public static function init(inDisplayObject:DisplayObject, inAlignment:String = TOP_RIGHT, inRec:Rectangle = null, inIsFollow:Boolean = false):void		{			new AlignUtil (inDisplayObject, inAlignment, inRec, inIsFollow);		}				private function startAlignmentHandler(event : Event) : void 		{			_displayObject.removeEventListener(Event.ADDED_TO_STAGE, startAlignmentHandler);			_displayObject.stage.addEventListener(Event.RESIZE, align);			_displayObject.addEventListener(Event.REMOVED_FROM_STAGE, stopAlignmentHandler);			align(null);		}				private function stopAlignmentHandler(event : Event) : void		{			_displayObject.removeEventListener(Event.REMOVED_FROM_STAGE, stopAlignmentHandler);			_displayObject.stage.removeEventListener(Event.RESIZE, align);		}		private function align(event : Event) : void 		{			switch (_alignment) {				default:				case TOP_LEFT:					// x = 0, y = 0 -> nothing to do here.					break;				case BOTTOM_LEFT:					_displayObject.y = _displayObject.stage.stageHeight - _rectangle.height;					break;				case BOTTOM_RIGHT:					_displayObject.y = _displayObject.stage.stageHeight - _rectangle.height;				case TOP_RIGHT:					_displayObject.x = _displayObject.stage.stageWidth - _rectangle.width;					break;				case CENTER:					_displayObject.y = Math.round((_displayObject.stage.stageHeight - _rectangle.height) / 2);					_displayObject.x = Math.round((_displayObject.stage.stageWidth - _rectangle.width) / 2);					break;				case CENTER_TOP:					_displayObject.y = 0;					_displayObject.x = Math.round((_displayObject.stage.stageWidth - _rectangle.width) / 2);					break;				case CENTER_BOTTOM:					_displayObject.y = _displayObject.stage.stageHeight - _rectangle.height;					_displayObject.x = Math.round((_displayObject.stage.stageWidth - _rectangle.width) / 2);					break;			}		}						/**		* arranges movie clips in a column as if they are in a VBox 		*  		* @param	clips		* @param	padding		*/		static public function vbox( clips:Array, padding:Number=2 ) : void {			var count:int = clips.length;			if(count<2) return;					var yPos:Number = (clips[0] as DisplayObject).getBounds( clips[0].parent ).bottom + padding;				for(var n:uint=1; n<count; ++n) {				var mc:DisplayObject = clips[n] as DisplayObject;				if(mc.visible==false) continue;				mc.y = Math.round( yPos + mc.y - mc.getBounds( mc.parent ).top);						yPos = mc.getBounds( mc.parent ).bottom + padding;			}				}				/**		* arranges movie clips in a row as if they are in a HBox		* 		* @param	clips		* @param	padding		*/		static public function hbox( clips:Array, padding:Number=2 ) : void {			var count:int = clips.length;			if(count<2) return;					var xPos:Number = (clips[0] as DisplayObject).getBounds( clips[0].parent ).right + padding;				for(var n:uint=1; n<count; ++n) {				var mc:DisplayObject = clips[n] as DisplayObject;				if(mc.visible==false) continue;				mc.x = Math.round( xPos + mc.x - mc.getBounds( mc.parent ).left);						xPos = mc.getBounds( mc.parent ).right + padding;			}				}				}}